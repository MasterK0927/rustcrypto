use std::collections::HashMap;

/**
 * ViterbiDecoder
 * - Constraint Length: K
 * - Generator Polynomials: G1, G2, ..., Gn
 * - Rate Denominator: R = 1/n
 * - Number of States: N
 */
pub struct ViterbiDecoder {
    constraint_length: u32,
    polynomials: Vec<u32>,
    num_states: usize,
    rate_denominator: usize,
}

/**
 * Path
 * - bits: The bits that form the path
 * - metric: The path metric (Hamming distance)
 */
struct Path {
    bits: Vec<bool>,
    metric: usize,
}

/**
 * ViterbiDecoder impl
 * - `new`: Create a new decoder with the given constraint length and polynomials
 * - `compute_output`: Compute the output for a given state and input bit
 * - `hamming_distance`: Calculate the Hamming distance between two bit sequences
 * - `decode`: Decode a sequence of input bits using the Viterbi algorithm
 */
impl ViterbiDecoder {

    pub fn new(constraint_length: u32, polynomials: Vec<u32>) -> Self {
        let binary_polynomials = polynomials.iter()
            .map(|&p| {
                let mut binary = 0;
                let mut octal = p;
                let mut shift = 0;
                
                while octal > 0 {
                    let digit = octal % 10;
                    binary |= digit << shift;
                    octal /= 10;
                    shift += 3;
                }
                
                binary
            })
            .collect::<Vec<_>>();
        
        let num_states = 1 << (constraint_length - 1);
        
        ViterbiDecoder {
            constraint_length,
            polynomials: binary_polynomials,
            num_states,
            rate_denominator: polynomials.len(),
        }
    }
    
    /**
     * compute_output
     * - state: The current state of the encoder
     * - input_bit: The input bit (0 or 1)
     * - Returns: The output bits generated by the encoder for the given state and input bit
     * 
     */
    fn compute_output(&self, state: usize, input_bit: bool) -> Vec<bool> {
        let register_mask = (1 << (self.constraint_length - 1)) - 1;
        let next_state = ((state << 1) | (if input_bit { 1 } else { 0 })) & register_mask;
        
        let mut output = Vec::with_capacity(self.rate_denominator);
        
        for &poly in &self.polynomials {
            let mut parity = 0;
            let mut temp = next_state & poly as usize;
            
            while temp != 0 {
                parity ^= temp & 1;
                temp >>= 1;
            }
            
            output.push(parity == 1);
        }
        output
    }
    
    /**
     * hamming_distance
     * - a: First bit sequence
     * - b: Second bit sequence
     * - Returns: The Hamming distance between the two sequences
     */
    fn hamming_distance(a: &[bool], b: &[bool]) -> usize {
        a.iter().zip(b.iter()).filter(|(&x, &y)| x != y).count()
    }
    
    
    /**
     * decode
     * - input: The encoded bit sequence to decode
     * - Returns: The decoded bit sequence
     */
    pub fn decode(&self, input: &[bool]) -> Vec<bool> {
        // Ensure the input length is a multiple of the rate denominator
        if input.len() % self.rate_denominator != 0 {
            panic!("Input length must be a multiple of {}", self.rate_denominator);
        }
        
        let num_symbols = input.len() / self.rate_denominator;
        
        // Initialize path metrics
        let mut paths: HashMap<usize, Path> = HashMap::new();
        paths.insert(0, Path { bits: Vec::new(), metric: 0 });
        
        // Process each input symbol
        for i in 0..num_symbols {
            let symbol = &input[i * self.rate_denominator..(i + 1) * self.rate_denominator];
            let mut new_paths: HashMap<usize, Path> = HashMap::new();
            
            // Consider all current paths
            for (state, path) in &paths {
                // Try both possible input bits
                for input_bit in [false, true].iter() {
                    // Compute next state
                    let next_state = ((state << 1) | if *input_bit { 1 } else { 0 }) & (self.num_states - 1);
                    
                    // Compute expected output
                    let expected_output = self.compute_output(*state, *input_bit);
                    
                    // Calculate branch metric (Hamming distance)
                    let branch_metric = Self::hamming_distance(symbol, &expected_output);
                    
                    // Calculate new path metric
                    let new_metric = path.metric + branch_metric;
                    
                    // Create new path
                    let mut new_bits = path.bits.clone();
                    new_bits.push(*input_bit);
                    
                    // Update best path to this state
                    if let Some(existing_path) = new_paths.get_mut(&next_state) {
                        if new_metric < existing_path.metric {
                            existing_path.bits = new_bits;
                            existing_path.metric = new_metric;
                        }
                    } else {
                        new_paths.insert(next_state, Path { bits: new_bits, metric: new_metric });
                    }
                }
            }
            
            paths = new_paths;
        }
        
        // Find the path with the minimum metric
        let best_path = paths.values()
            .min_by_key(|path| path.metric)
            .expect("No valid paths found");
        
        best_path.bits.clone()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::convolutional::encoder::ConvolutionalEncoder;

    #[test]
    fn test_viterbi_decode() {
        let mut encoder = ConvolutionalEncoder::new(3, vec![7, 5]);
        let message = vec![true, false, true, true, false, true, false, true];
        let encoded = encoder.encode(&message);
        let decoder = ViterbiDecoder::new(3, vec![7, 5]);
        let decoded = decoder.decode(&encoded);
        assert_eq!(message, decoded);
    }
}